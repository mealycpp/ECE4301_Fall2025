use std::time::Instant;
use std::io::{self, Write};

// === AES-128 Key Expansion ===
fn schedule_key(key: [u8; 16]) -> [[u8; 16]; 11] {
    const RCON: [u8; 10] = [0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36];
    let sbox = sbox_aes();

    let mut rk = [[0u8; 16]; 11];
    rk[0] = key;

    for i in 1..=10 {
        let prev = rk[i - 1];
        let mut temp = [prev[13], prev[14], prev[15], prev[12]];
        for j in 0..4 {
            temp[j] = sbox[temp[j] as usize];
        }
        temp[0] ^= RCON[i - 1];

        for j in 0..4 {
            rk[i][j] = prev[j] ^ temp[j];
        }
        for j in 4..16 {
            rk[i][j] = rk[i][j - 4] ^ prev[j];
        }
    }

    rk
}

// === AES-128 Encryption ===
fn encrypt_sw(mut state: [u8; 16], round_keys: &[[u8; 16]; 11]) -> [u8; 16] {
    add_round_key(&mut state, &round_keys[0]);

    for round in 1..10 {
        sub_bytes(&mut state);
        shift_rows(&mut state);
        mix_columns(&mut state);
        add_round_key(&mut state, &round_keys[round]);
    }

    sub_bytes(&mut state);
    shift_rows(&mut state);
    add_round_key(&mut state, &round_keys[10]);

    state
}

// === AES Core Functions ===

fn sub_bytes(state: &mut [u8; 16]) {
    let sbox = sbox_aes();
    for b in state.iter_mut() {
        *b = sbox[*b as usize];
    }
}

fn shift_rows(state: &mut [u8; 16]) {
    let tmp = state.clone();

    state[0] = tmp[0];
    state[1] = tmp[5];
    state[2] = tmp[10];
    state[3] = tmp[15];

    state[4] = tmp[4];
    state[5] = tmp[9];
    state[6] = tmp[14];
    state[7] = tmp[3];

    state[8] = tmp[8];
    state[9] = tmp[13];
    state[10] = tmp[2];
    state[11] = tmp[7];

    state[12] = tmp[12];
    state[13] = tmp[1];
    state[14] = tmp[6];
    state[15] = tmp[11];
}

fn mix_columns(state: &mut [u8; 16]) {
    fn xtime(x: u8) -> u8 {
        if x & 0x80 != 0 {
            (x << 1) ^ 0x1b
        } else {
            x << 1
        }
    }

    for i in 0..4 {
        let col = &mut state[i*4..(i+1)*4];
        let t = col[0] ^ col[1] ^ col[2] ^ col[3];
        let tmp = col[0];
        col[0] ^= t ^ xtime(col[0] ^ col[1]);
        col[1] ^= t ^ xtime(col[1] ^ col[2]);
        col[2] ^= t ^ xtime(col[2] ^ col[3]);
        col[3] ^= t ^ xtime(col[3] ^ tmp);
    }
}

fn add_round_key(state: &mut [u8; 16], key: &[u8; 16]) {
    for i in 0..16 {
        state[i] ^= key[i];
    }
}

// === AES S-box ===
const fn sbox_aes() -> [u8; 256] {
    [
        0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
        0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
        0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
        0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
        0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
        0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
        0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
        0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
        0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
        0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
        0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
        0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
        0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
        0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
        0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
        0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16
    ]
}

// === MAIN ===
fn main() {
    let key_vec  = [0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c];
    let pt_vec   = [0x32,0x43,0xf6,0xa8,0x88,0x5a,0x30,0x8d,0x31,0x31,0x98,0xa2,0xe0,0x37,0x07,0x34];
    let ct_expect= [0x39,0x25,0x84,0x1d,0x02,0xdc,0x09,0xfb,0xdc,0x11,0x85,0x97,0x19,0x6a,0x0b,0x32];

    let round_keys = schedule_key(key_vec);
    let ct = encrypt_sw(pt_vec, &round_keys);

    assert_eq!(ct, ct_expect, "Self-test failed ‚ùå");
    println!("Self-test Success");

    // --- Read user input ---
    print!("Enter text to encrypt (max 16 chars): ");
    io::stdout().flush().unwrap();

    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();
    let input = input.trim_end();

    // Prepare 16-byte block (pad with zeros if shorter)
    let mut block = [0u8; 16];
    let input_bytes = input.as_bytes();
    let len = input_bytes.len().min(16);
    block[..len].copy_from_slice(&input_bytes[..len]);

    // Encrypt
    let ciphertext = encrypt_sw(block, &round_keys);

    println!("Ciphertext (hex) for user input:");
    for byte in &ciphertext {
        print!("{:02x} ", byte);
    }
    println!();


    // Benchmark
    const N: usize = 100_000;
    let mut s = [0u8; 16];
    let start = Instant::now();
    for _ in 0..N {
        s = encrypt_sw(s, &round_keys);
    }
    let elapsed = start.elapsed();

    println!("Iterations: {}", N);
    println!("Last ciphertext: {:02x?}", s);
    println!("Total time: {:.3?}", elapsed);
    println!("Average per block: {:.2} ns", elapsed.as_nanos() as f64 / N as f64);
}
